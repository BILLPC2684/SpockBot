#!/usr/bin/python
import os, sys, signal, time, argparse
from os import path
from spock.utils import daemonize

signals = []

from spock.net.client import Client
from plugins import DebugPlugin, ReConnect, AntiAFK
plugins = [ReConnect.ReConnectPlugin, DebugPlugin.DebugPlugin, AntiAFK.AntiAFKPlugin]
testclient = Client(plugins = plugins)

def handleSignal(sig, handle):
	signals.append(sig)
	signal.signal(sig, handle)

def printreturn(val):
	print str(val)
	return val

class spockd:
	def __init__(self):
		self.args = self.parseargs()

		self.stop = False
		self.pids = {}
		self.names = {}
		spockd_dir = path.join(path.expanduser('~'), '.spockd')
		self.dirs = {
			'spockd': spockd_dir,
			'proc': path.join(spockd_dir, 'proc'),
			'bots': path.join(spockd_dir, 'bots'),
			'logins': path.join(spockd_dir, 'logins'),
		}
		self.inpipe = path.join(self.dirs['spockd'], 'inpipe')
		self.outpipe = path.join(self.dirs['spockd'], 'outpipe')
		self.pidfile = path.join(self.dirs['spockd'], 'spockd.pid')
		self.logfile = path.join(self.dirs['spockd'], 'spockd.log')

		self.parser = argparse.ArgumentParser()
		sub_parsers = self.parser.add_subparsers()

		start_parser = sub_parsers.add_parser('start')
		start_parser.add_argument('name')
		start_parser.add_argument('-b', '--bot')
		start_parser.add_argument('-l', '--login')
		start_parser.add_argument('-u', '--user')
		start_parser.add_argument('-p', '--pass')

		stop_parser = sub_parsers.add_parser('stop')
		stop_parser.add_argument('name')


		self.commands = {
			'start': self.handle_start,
			'stop': self.handle_stop,
			#'restart': self.handle_restart,
			#'status': self.handle_status,
		}

	def parseargs(self):
		args = {}
		args['daemon'] = (True if (len(sys.argv)>1 and sys.argv[1] == '-D') else False)
		return args

	def start(self):
		for dpath in self.dirs.values():
			if not path.exists(dpath):
				os.makedirs(dpath)

		if path.exists(self.pidfile):
			print "spockd PID already exists"
			sys.exit(0)

		f = open(self.pidfile, 'w')
		f.write(str(os.getpid()))
		f.close()

		if not path.exists(self.inpipe):
			os.mkfifo(self.inpipe)
		if not path.exists(self.outpipe):
			os.mkfifo(self.outpipe)

		self.run()

	def run(self):
		if self.args['daemon']:
			daemonize()
			sys.stdout = sys.stderr = open(self.logfile, 'w')
		while not self.stop:
			try:
				readpipe = open(self.inpipe, 'r')
				cmd = readpipe.read()
				readpipe.close()
				toreturn = self.run_cmd(cmd)
				writepipe = open(self.outpipe, 'w')
				writepipe.write(toreturn)
				writepipe.close()
			except IOError, e:
				if e.errno != 4:
					print str(e)
					self.exit()

	def run_cmd(self, cmd):
		if not cmd:
			return "No Command"
		cmd = cmd.split()
		op = cmd[0].lower()
		if not op in self.commands:
			return "Invalid Command"
		args = vars(self.parser.parse_args(cmd))
		toreturn = self.commands[op](args)
		return str(toreturn)


	def handle_start(self, args):
		if args['login'] != None:
			f = path.join(self.dirs['logins'], args['login'])
			if not path.exists(f):
				return "No such login"
			f = open(f, 'r')
			for line in f.readlines():
				line = line.split()
				if line[0].lower() == 'username' or line[0].lower() == 'user':
					username = line[2]
				if line[0].lower() == 'password' or line[0].lower() == 'pass':
					password = line[2]
			f.close()
		elif args['user']!=None and args['pass']!=None:
			username = args['user']
			password = args['pass']
		else:
			return "Not enough login information"

		name = args['name']
		folder = path.join(self.dirs['proc'], name)
		pidfile = path.join(folder, name+'.pid')
		logfile = path.join(folder, name+'.log')
		if path.exists(pidfile):
			return "PID already exists for that name"
		if not path.exists(folder):
			os.makedirs(folder)

		pid = os.fork()
		#Child process
		if pid == 0:
			#Set the signal handlers back to default
			for sig in signals:
				signal.signal(sig, signal.SIG_DFL)
			testclient.daemon = True
			testclient.pidfile = pidfile
			testclient.logfile = logfile
			testclient.start(username, password)

		self.pids[pid] = name
		self.names[name] = pid
		return pid

	def handle_stop(self, args):
		name = args['name']
		folder = path.join(self.dirs['proc'], name)
		pidfile = path.join(folder, name+'.pid')
		if path.exists(pidfile):
			pid = int(open(pidfile, 'r').readline())
			os.kill(pid, signal.SIGTERM)
			return "SIGTERM sent to PID: " + str(pid)
		else:
			return "No PID exists for that name"

	def exit(self):
		for pid in self.pids:
			print "Sending SIGTERM to PID:", pid
			os.kill(pid, signal.SIGTERM)
		while self.pids:
			print "Waiting for all children to terminate..."
			time.sleep(1)
		print "All children terminated, shutting down"
		os.remove(self.pidfile)
		os.remove(self.inpipe)
		os.remove(self.outpipe)
		sys.exit(0)

	def handleSIGCHLD(self, *args):
		pid = os.waitpid(-1, 0)[0]
		name = self.pids[pid]
		del self.pids[pid]
		del self.names[name]
		print "Child PID", pid, "has terminated"

	def handleSIGTERM(self, *args):
		self.exit()

	handleSIGINT = handleSIGTERM


spock_daemon = spockd()

handleSignal(signal.SIGCHLD, spock_daemon.handleSIGCHLD)
handleSignal(signal.SIGTERM, spock_daemon.handleSIGTERM)
handleSignal(signal.SIGINT, spock_daemon.handleSIGINT)

if __name__ == '__main__':
	spock_daemon.start()
	